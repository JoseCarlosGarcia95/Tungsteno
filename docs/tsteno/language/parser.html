<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tsteno.language.parser API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tsteno.language.parser</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numbers
from collections import namedtuple
import tsteno.language.token_list as token_list
from tsteno.language.ast import Node, IdentifierToken


class BaseParser:
    def read(self, tokens, toklen, pos, parser):
        raise Exception(&#34;Undefined `read` function&#34;)


class BasicAtomParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        return tokens[pos].get_value(), pos + 1


class UnaryOpParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        token = tokens[pos]

        if token.get_value() == &#39;-&#39;:
            atom, pos = parser.compute_atom(tokens, toklen, pos + 1)

            return Node(&#39;ChangeSign&#39;, atom), pos
        elif token.get_value() == &#39;+&#39;:
            if (pos + 1 &lt; toklen and
                    token.get_type() == token_list.TOKEN_OP and
                    token.get_value() == &#39;+&#39;):
                atom, pos = parser.compute_atom(tokens, toklen, pos + 2)
                return Node(&#39;PreIncrement&#39;, atom), pos
            atom, pos = parser.compute_atom(tokens, toklen, pos + 1)
            return atom, pos

        raise Exception()


class IdentifierTokenParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        itok = tokens[pos]

        if pos + 1 &lt; toklen:
            ntok = tokens[pos + 1]
            if ntok.get_type() == token_list.TOKEN_LEFTFUNC:
                pos = pos + 2

                arg = []
                arguments = []
                while pos &lt; toklen:
                    ntok = tokens[pos]

                    if ntok.get_type() == token_list.TOKEN_COMMA_SEPARATOR:
                        arguments.append(arg[0] if len(arg) == 1 else arg)
                        arg = []

                        pos = pos + 1
                        continue
                    elif ntok.get_type() == token_list.TOKEN_RIGHTFUNC:
                        arguments.append(arg[0] if len(arg) == 1 else arg)
                        pos = pos + 1
                        break
                    expr, pos = parser.compute_expr(tokens, toklen, pos)

                    arg.append(expr)

                return Node(itok.get_value(), *arguments), pos

        return IdentifierToken(itok.get_value()), pos + 1


class ListTokenParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        if pos &lt; toklen:
            pos = pos + 1
            arguments = []

            while pos &lt; toklen:
                ntok = tokens[pos]

                if ntok.get_type() == token_list.TOKEN_COMMA_SEPARATOR:
                    pos = pos + 1
                    continue
                elif ntok.get_type() == token_list.TOKEN_RIGHTLIST:
                    pos = pos + 1
                    break
                expr, pos = parser.compute_expr(tokens, toklen, pos)
                arguments.append(expr)

            return Node(&#39;List&#39;, *arguments), pos

        raise Exception()


class ParensParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        expr, pos = parser.compute_expr(tokens, toklen, pos + 1)

        if tokens[pos].get_type() != token_list.TOKEN_RIGHTPAREN:
            raise Exception(
                &#34;Syntax error unexpected #{} ({}) at {}&#34;.format(
                    tokens[pos].get_type(), tokens[pos].get_value(),
                    tokens[pos].pos + 1)
            )

        return expr, pos + 1


OpInfo = namedtuple(&#39;OpInfo&#39;, &#39;prec assoc function&#39;)

BIN_OPINFO_MAP = {
    &#39;/.&#39;: OpInfo(-1, &#39;LEFT&#39;, &#39;ReplaceAll&#39;),

    &#39;-&gt;&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;Rule&#39;),
    &#39;=&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;Set&#39;),
    &#39;:=&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;Set&#39;),
    &#39;&lt;&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;LessThan&#39;),
    &#39;&lt;=&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;LessEqual&#39;),
    &#39;&gt;&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;GreaterThan&#39;),
    &#39;&gt;=&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;GreaterEqual&#39;),
    &#39;==&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;Equal&#39;),
    &#39;!=&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;NotEqual&#39;),
    &#39;*^&#39;: OpInfo(0, &#39;LEFT&#39;, &#39;ScientificForm&#39;),

    &#39;+&#39;: OpInfo(1, &#39;LEFT&#39;, &#39;Plus&#39;),
    &#39;-&#39;: OpInfo(1, &#39;LEFT&#39;, &#39;Minus&#39;),

    &#39;*&#39;: OpInfo(2, &#39;LEFT&#39;, &#39;Product&#39;),
    &#39;/&#39;: OpInfo(2, &#39;LEFT&#39;, &#39;Div&#39;),

    &#39;^&#39;: OpInfo(3, &#39;RIGHT&#39;, &#39;Pow&#39;),
}

UNARY_OPINFO_MAP = {
    &#39;++&#39;: OpInfo(None, None, &#39;Increment&#39;),
    &#39;--&#39;: OpInfo(None, None, &#39;Decrement&#39;)

}

CLOSURE_TOKENS = [
    token_list.TOKEN_CLOSE_EXPR, token_list.TOKEN_NEWLINE,
    token_list.TOKEN_COMMA_SEPARATOR, token_list.TOKEN_RIGHTFUNC,
    token_list.TOKEN_RIGHTLIST, token_list.TOKEN_RIGHTPAREN
]


class Parser:
    __slots__ = (&#39;parser_processors&#39;, &#39;binary_ops&#39;)

    def __init__(self):
        basic_atom_parser = BasicAtomParser()

        self.parser_processors = {
            token_list.TOKEN_NUMBER: basic_atom_parser,
            token_list.TOKEN_STRING: basic_atom_parser,
            token_list.TOKEN_OP: UnaryOpParser(),
            token_list.TOKEN_LEFTPAREN: ParensParser(),
            token_list.TOKEN_IDENTIFIER: IdentifierTokenParser(),
            token_list.TOKEN_LEFTLIST: ListTokenParser(),
        }

    def compute_expr(self, tokens, toklen, pos, minprec=-1):
        atom_lhs, pos = self.compute_atom(tokens, toklen, pos)

        while pos &lt; toklen and (
            tokens[pos].get_type() not in CLOSURE_TOKENS
        ):
            token = tokens[pos]
            next_token = None
            if pos + 1 &lt; toklen:
                next_token = tokens[pos + 1]

            if token.get_type() == token_list.TOKEN_OP and \
                    next_token.get_type() == token.get_type():
                double_op = token.get_value() + next_token.get_value()
                if double_op in UNARY_OPINFO_MAP:
                    prec, assoc, node = UNARY_OPINFO_MAP[double_op]
                    pos = pos + 2

                    atom_lhs = self.compute_unary(node, atom_lhs)
                    continue

            if token.get_type() == token_list.TOKEN_OP:
                op = token.get_value()

                if pos + 1 &lt; toklen and \
                        tokens[pos + 1].get_type() == token_list.TOKEN_OP:
                    double_op = &#34;&#34;.join([op, tokens[pos + 1].get_value()])
                    if double_op in BIN_OPINFO_MAP:
                        op = double_op

                prec, assoc, node = BIN_OPINFO_MAP[op]
                if prec &lt; minprec:
                    break

                next_min_prec = prec + 1 if assoc == &#39;LEFT&#39; else prec

                pos = pos + len(op)

                atom_rhs, pos = self.compute_expr(
                    tokens, toklen, pos, next_min_prec
                )

                atom_lhs = self.compute_binop(node, atom_lhs, atom_rhs)
            elif isinstance(atom_lhs, numbers.Number):
                prec, assoc, node = BIN_OPINFO_MAP[&#39;*&#39;]

                next_min_prec = prec + 1 if assoc == &#39;LEFT&#39; else prec

                atom_rhs, pos = self.compute_expr(
                    tokens, toklen, pos, next_min_prec
                )

                atom_lhs = self.compute_binop(node, atom_lhs, atom_rhs)
            else:
                raise Exception(str(token))

        return atom_lhs, pos

    def compute_binop(self, node, lhs, rhs):
        return Node(node, lhs, rhs)

    def compute_unary(self, node, lhs):
        return Node(node, lhs)

    def compute_atom(self, tokens, toklen, pos):
        while tokens[pos].get_type() in CLOSURE_TOKENS:
            pos = pos + 1
            if pos &gt;= toklen:
                return None, pos

        token = tokens[pos]

        if token.get_type() not in self.parser_processors:
            raise Exception(
                &#34;Syntax error unexpected #{} ({}) at {}&#34;.format(
                    token.get_type(), token.get_value(), token.pos + 1)
            )

        return self.parser_processors[token.get_type()].read(
            tokens, toklen, pos, self
        )

    def get_nodes(self, tokens):
        pos = 0
        toklen = len(tokens)
        last_node = None

        while pos &lt; toklen:
            last_node, pos = self.compute_expr(tokens, toklen, pos)
            if last_node is not None:
                yield last_node</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tsteno.language.parser.BaseParser"><code class="flex name class">
<span>class <span class="ident">BaseParser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseParser:
    def read(self, tokens, toklen, pos, parser):
        raise Exception(&#34;Undefined `read` function&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tsteno.language.parser.BasicAtomParser" href="#tsteno.language.parser.BasicAtomParser">BasicAtomParser</a></li>
<li><a title="tsteno.language.parser.IdentifierTokenParser" href="#tsteno.language.parser.IdentifierTokenParser">IdentifierTokenParser</a></li>
<li><a title="tsteno.language.parser.ListTokenParser" href="#tsteno.language.parser.ListTokenParser">ListTokenParser</a></li>
<li><a title="tsteno.language.parser.ParensParser" href="#tsteno.language.parser.ParensParser">ParensParser</a></li>
<li><a title="tsteno.language.parser.UnaryOpParser" href="#tsteno.language.parser.UnaryOpParser">UnaryOpParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsteno.language.parser.BaseParser.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, tokens, toklen, pos, parser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, tokens, toklen, pos, parser):
    raise Exception(&#34;Undefined `read` function&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsteno.language.parser.BasicAtomParser"><code class="flex name class">
<span>class <span class="ident">BasicAtomParser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasicAtomParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        return tokens[pos].get_value(), pos + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tsteno.language.parser.BaseParser" href="#tsteno.language.parser.BaseParser">BaseParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsteno.language.parser.BasicAtomParser.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, tokens, toklen, pos, parser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, tokens, toklen, pos, parser):
    return tokens[pos].get_value(), pos + 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsteno.language.parser.IdentifierTokenParser"><code class="flex name class">
<span>class <span class="ident">IdentifierTokenParser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdentifierTokenParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        itok = tokens[pos]

        if pos + 1 &lt; toklen:
            ntok = tokens[pos + 1]
            if ntok.get_type() == token_list.TOKEN_LEFTFUNC:
                pos = pos + 2

                arg = []
                arguments = []
                while pos &lt; toklen:
                    ntok = tokens[pos]

                    if ntok.get_type() == token_list.TOKEN_COMMA_SEPARATOR:
                        arguments.append(arg[0] if len(arg) == 1 else arg)
                        arg = []

                        pos = pos + 1
                        continue
                    elif ntok.get_type() == token_list.TOKEN_RIGHTFUNC:
                        arguments.append(arg[0] if len(arg) == 1 else arg)
                        pos = pos + 1
                        break
                    expr, pos = parser.compute_expr(tokens, toklen, pos)

                    arg.append(expr)

                return Node(itok.get_value(), *arguments), pos

        return IdentifierToken(itok.get_value()), pos + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tsteno.language.parser.BaseParser" href="#tsteno.language.parser.BaseParser">BaseParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsteno.language.parser.IdentifierTokenParser.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, tokens, toklen, pos, parser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, tokens, toklen, pos, parser):
    itok = tokens[pos]

    if pos + 1 &lt; toklen:
        ntok = tokens[pos + 1]
        if ntok.get_type() == token_list.TOKEN_LEFTFUNC:
            pos = pos + 2

            arg = []
            arguments = []
            while pos &lt; toklen:
                ntok = tokens[pos]

                if ntok.get_type() == token_list.TOKEN_COMMA_SEPARATOR:
                    arguments.append(arg[0] if len(arg) == 1 else arg)
                    arg = []

                    pos = pos + 1
                    continue
                elif ntok.get_type() == token_list.TOKEN_RIGHTFUNC:
                    arguments.append(arg[0] if len(arg) == 1 else arg)
                    pos = pos + 1
                    break
                expr, pos = parser.compute_expr(tokens, toklen, pos)

                arg.append(expr)

            return Node(itok.get_value(), *arguments), pos

    return IdentifierToken(itok.get_value()), pos + 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsteno.language.parser.ListTokenParser"><code class="flex name class">
<span>class <span class="ident">ListTokenParser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListTokenParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        if pos &lt; toklen:
            pos = pos + 1
            arguments = []

            while pos &lt; toklen:
                ntok = tokens[pos]

                if ntok.get_type() == token_list.TOKEN_COMMA_SEPARATOR:
                    pos = pos + 1
                    continue
                elif ntok.get_type() == token_list.TOKEN_RIGHTLIST:
                    pos = pos + 1
                    break
                expr, pos = parser.compute_expr(tokens, toklen, pos)
                arguments.append(expr)

            return Node(&#39;List&#39;, *arguments), pos

        raise Exception()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tsteno.language.parser.BaseParser" href="#tsteno.language.parser.BaseParser">BaseParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsteno.language.parser.ListTokenParser.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, tokens, toklen, pos, parser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, tokens, toklen, pos, parser):
    if pos &lt; toklen:
        pos = pos + 1
        arguments = []

        while pos &lt; toklen:
            ntok = tokens[pos]

            if ntok.get_type() == token_list.TOKEN_COMMA_SEPARATOR:
                pos = pos + 1
                continue
            elif ntok.get_type() == token_list.TOKEN_RIGHTLIST:
                pos = pos + 1
                break
            expr, pos = parser.compute_expr(tokens, toklen, pos)
            arguments.append(expr)

        return Node(&#39;List&#39;, *arguments), pos

    raise Exception()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsteno.language.parser.OpInfo"><code class="flex name class">
<span>class <span class="ident">OpInfo</span></span>
<span>(</span><span>prec, assoc, function)</span>
</code></dt>
<dd>
<div class="desc"><p>OpInfo(prec, assoc, function)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tsteno.language.parser.OpInfo.assoc"><code class="name">var <span class="ident">assoc</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="tsteno.language.parser.OpInfo.function"><code class="name">var <span class="ident">function</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="tsteno.language.parser.OpInfo.prec"><code class="name">var <span class="ident">prec</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="tsteno.language.parser.ParensParser"><code class="flex name class">
<span>class <span class="ident">ParensParser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParensParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        expr, pos = parser.compute_expr(tokens, toklen, pos + 1)

        if tokens[pos].get_type() != token_list.TOKEN_RIGHTPAREN:
            raise Exception(
                &#34;Syntax error unexpected #{} ({}) at {}&#34;.format(
                    tokens[pos].get_type(), tokens[pos].get_value(),
                    tokens[pos].pos + 1)
            )

        return expr, pos + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tsteno.language.parser.BaseParser" href="#tsteno.language.parser.BaseParser">BaseParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsteno.language.parser.ParensParser.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, tokens, toklen, pos, parser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, tokens, toklen, pos, parser):
    expr, pos = parser.compute_expr(tokens, toklen, pos + 1)

    if tokens[pos].get_type() != token_list.TOKEN_RIGHTPAREN:
        raise Exception(
            &#34;Syntax error unexpected #{} ({}) at {}&#34;.format(
                tokens[pos].get_type(), tokens[pos].get_value(),
                tokens[pos].pos + 1)
        )

    return expr, pos + 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsteno.language.parser.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parser:
    __slots__ = (&#39;parser_processors&#39;, &#39;binary_ops&#39;)

    def __init__(self):
        basic_atom_parser = BasicAtomParser()

        self.parser_processors = {
            token_list.TOKEN_NUMBER: basic_atom_parser,
            token_list.TOKEN_STRING: basic_atom_parser,
            token_list.TOKEN_OP: UnaryOpParser(),
            token_list.TOKEN_LEFTPAREN: ParensParser(),
            token_list.TOKEN_IDENTIFIER: IdentifierTokenParser(),
            token_list.TOKEN_LEFTLIST: ListTokenParser(),
        }

    def compute_expr(self, tokens, toklen, pos, minprec=-1):
        atom_lhs, pos = self.compute_atom(tokens, toklen, pos)

        while pos &lt; toklen and (
            tokens[pos].get_type() not in CLOSURE_TOKENS
        ):
            token = tokens[pos]
            next_token = None
            if pos + 1 &lt; toklen:
                next_token = tokens[pos + 1]

            if token.get_type() == token_list.TOKEN_OP and \
                    next_token.get_type() == token.get_type():
                double_op = token.get_value() + next_token.get_value()
                if double_op in UNARY_OPINFO_MAP:
                    prec, assoc, node = UNARY_OPINFO_MAP[double_op]
                    pos = pos + 2

                    atom_lhs = self.compute_unary(node, atom_lhs)
                    continue

            if token.get_type() == token_list.TOKEN_OP:
                op = token.get_value()

                if pos + 1 &lt; toklen and \
                        tokens[pos + 1].get_type() == token_list.TOKEN_OP:
                    double_op = &#34;&#34;.join([op, tokens[pos + 1].get_value()])
                    if double_op in BIN_OPINFO_MAP:
                        op = double_op

                prec, assoc, node = BIN_OPINFO_MAP[op]
                if prec &lt; minprec:
                    break

                next_min_prec = prec + 1 if assoc == &#39;LEFT&#39; else prec

                pos = pos + len(op)

                atom_rhs, pos = self.compute_expr(
                    tokens, toklen, pos, next_min_prec
                )

                atom_lhs = self.compute_binop(node, atom_lhs, atom_rhs)
            elif isinstance(atom_lhs, numbers.Number):
                prec, assoc, node = BIN_OPINFO_MAP[&#39;*&#39;]

                next_min_prec = prec + 1 if assoc == &#39;LEFT&#39; else prec

                atom_rhs, pos = self.compute_expr(
                    tokens, toklen, pos, next_min_prec
                )

                atom_lhs = self.compute_binop(node, atom_lhs, atom_rhs)
            else:
                raise Exception(str(token))

        return atom_lhs, pos

    def compute_binop(self, node, lhs, rhs):
        return Node(node, lhs, rhs)

    def compute_unary(self, node, lhs):
        return Node(node, lhs)

    def compute_atom(self, tokens, toklen, pos):
        while tokens[pos].get_type() in CLOSURE_TOKENS:
            pos = pos + 1
            if pos &gt;= toklen:
                return None, pos

        token = tokens[pos]

        if token.get_type() not in self.parser_processors:
            raise Exception(
                &#34;Syntax error unexpected #{} ({}) at {}&#34;.format(
                    token.get_type(), token.get_value(), token.pos + 1)
            )

        return self.parser_processors[token.get_type()].read(
            tokens, toklen, pos, self
        )

    def get_nodes(self, tokens):
        pos = 0
        toklen = len(tokens)
        last_node = None

        while pos &lt; toklen:
            last_node, pos = self.compute_expr(tokens, toklen, pos)
            if last_node is not None:
                yield last_node</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tsteno.language.parser.Parser.binary_ops"><code class="name">var <span class="ident">binary_ops</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="tsteno.language.parser.Parser.parser_processors"><code class="name">var <span class="ident">parser_processors</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tsteno.language.parser.Parser.compute_atom"><code class="name flex">
<span>def <span class="ident">compute_atom</span></span>(<span>self, tokens, toklen, pos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_atom(self, tokens, toklen, pos):
    while tokens[pos].get_type() in CLOSURE_TOKENS:
        pos = pos + 1
        if pos &gt;= toklen:
            return None, pos

    token = tokens[pos]

    if token.get_type() not in self.parser_processors:
        raise Exception(
            &#34;Syntax error unexpected #{} ({}) at {}&#34;.format(
                token.get_type(), token.get_value(), token.pos + 1)
        )

    return self.parser_processors[token.get_type()].read(
        tokens, toklen, pos, self
    )</code></pre>
</details>
</dd>
<dt id="tsteno.language.parser.Parser.compute_binop"><code class="name flex">
<span>def <span class="ident">compute_binop</span></span>(<span>self, node, lhs, rhs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_binop(self, node, lhs, rhs):
    return Node(node, lhs, rhs)</code></pre>
</details>
</dd>
<dt id="tsteno.language.parser.Parser.compute_expr"><code class="name flex">
<span>def <span class="ident">compute_expr</span></span>(<span>self, tokens, toklen, pos, minprec=-1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_expr(self, tokens, toklen, pos, minprec=-1):
    atom_lhs, pos = self.compute_atom(tokens, toklen, pos)

    while pos &lt; toklen and (
        tokens[pos].get_type() not in CLOSURE_TOKENS
    ):
        token = tokens[pos]
        next_token = None
        if pos + 1 &lt; toklen:
            next_token = tokens[pos + 1]

        if token.get_type() == token_list.TOKEN_OP and \
                next_token.get_type() == token.get_type():
            double_op = token.get_value() + next_token.get_value()
            if double_op in UNARY_OPINFO_MAP:
                prec, assoc, node = UNARY_OPINFO_MAP[double_op]
                pos = pos + 2

                atom_lhs = self.compute_unary(node, atom_lhs)
                continue

        if token.get_type() == token_list.TOKEN_OP:
            op = token.get_value()

            if pos + 1 &lt; toklen and \
                    tokens[pos + 1].get_type() == token_list.TOKEN_OP:
                double_op = &#34;&#34;.join([op, tokens[pos + 1].get_value()])
                if double_op in BIN_OPINFO_MAP:
                    op = double_op

            prec, assoc, node = BIN_OPINFO_MAP[op]
            if prec &lt; minprec:
                break

            next_min_prec = prec + 1 if assoc == &#39;LEFT&#39; else prec

            pos = pos + len(op)

            atom_rhs, pos = self.compute_expr(
                tokens, toklen, pos, next_min_prec
            )

            atom_lhs = self.compute_binop(node, atom_lhs, atom_rhs)
        elif isinstance(atom_lhs, numbers.Number):
            prec, assoc, node = BIN_OPINFO_MAP[&#39;*&#39;]

            next_min_prec = prec + 1 if assoc == &#39;LEFT&#39; else prec

            atom_rhs, pos = self.compute_expr(
                tokens, toklen, pos, next_min_prec
            )

            atom_lhs = self.compute_binop(node, atom_lhs, atom_rhs)
        else:
            raise Exception(str(token))

    return atom_lhs, pos</code></pre>
</details>
</dd>
<dt id="tsteno.language.parser.Parser.compute_unary"><code class="name flex">
<span>def <span class="ident">compute_unary</span></span>(<span>self, node, lhs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_unary(self, node, lhs):
    return Node(node, lhs)</code></pre>
</details>
</dd>
<dt id="tsteno.language.parser.Parser.get_nodes"><code class="name flex">
<span>def <span class="ident">get_nodes</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodes(self, tokens):
    pos = 0
    toklen = len(tokens)
    last_node = None

    while pos &lt; toklen:
        last_node, pos = self.compute_expr(tokens, toklen, pos)
        if last_node is not None:
            yield last_node</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsteno.language.parser.UnaryOpParser"><code class="flex name class">
<span>class <span class="ident">UnaryOpParser</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryOpParser(BaseParser):
    def read(self, tokens, toklen, pos, parser):
        token = tokens[pos]

        if token.get_value() == &#39;-&#39;:
            atom, pos = parser.compute_atom(tokens, toklen, pos + 1)

            return Node(&#39;ChangeSign&#39;, atom), pos
        elif token.get_value() == &#39;+&#39;:
            if (pos + 1 &lt; toklen and
                    token.get_type() == token_list.TOKEN_OP and
                    token.get_value() == &#39;+&#39;):
                atom, pos = parser.compute_atom(tokens, toklen, pos + 2)
                return Node(&#39;PreIncrement&#39;, atom), pos
            atom, pos = parser.compute_atom(tokens, toklen, pos + 1)
            return atom, pos

        raise Exception()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tsteno.language.parser.BaseParser" href="#tsteno.language.parser.BaseParser">BaseParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsteno.language.parser.UnaryOpParser.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, tokens, toklen, pos, parser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, tokens, toklen, pos, parser):
    token = tokens[pos]

    if token.get_value() == &#39;-&#39;:
        atom, pos = parser.compute_atom(tokens, toklen, pos + 1)

        return Node(&#39;ChangeSign&#39;, atom), pos
    elif token.get_value() == &#39;+&#39;:
        if (pos + 1 &lt; toklen and
                token.get_type() == token_list.TOKEN_OP and
                token.get_value() == &#39;+&#39;):
            atom, pos = parser.compute_atom(tokens, toklen, pos + 2)
            return Node(&#39;PreIncrement&#39;, atom), pos
        atom, pos = parser.compute_atom(tokens, toklen, pos + 1)
        return atom, pos

    raise Exception()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tsteno.language" href="index.html">tsteno.language</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tsteno.language.parser.BaseParser" href="#tsteno.language.parser.BaseParser">BaseParser</a></code></h4>
<ul class="">
<li><code><a title="tsteno.language.parser.BaseParser.read" href="#tsteno.language.parser.BaseParser.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsteno.language.parser.BasicAtomParser" href="#tsteno.language.parser.BasicAtomParser">BasicAtomParser</a></code></h4>
<ul class="">
<li><code><a title="tsteno.language.parser.BasicAtomParser.read" href="#tsteno.language.parser.BasicAtomParser.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsteno.language.parser.IdentifierTokenParser" href="#tsteno.language.parser.IdentifierTokenParser">IdentifierTokenParser</a></code></h4>
<ul class="">
<li><code><a title="tsteno.language.parser.IdentifierTokenParser.read" href="#tsteno.language.parser.IdentifierTokenParser.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsteno.language.parser.ListTokenParser" href="#tsteno.language.parser.ListTokenParser">ListTokenParser</a></code></h4>
<ul class="">
<li><code><a title="tsteno.language.parser.ListTokenParser.read" href="#tsteno.language.parser.ListTokenParser.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsteno.language.parser.OpInfo" href="#tsteno.language.parser.OpInfo">OpInfo</a></code></h4>
<ul class="">
<li><code><a title="tsteno.language.parser.OpInfo.assoc" href="#tsteno.language.parser.OpInfo.assoc">assoc</a></code></li>
<li><code><a title="tsteno.language.parser.OpInfo.function" href="#tsteno.language.parser.OpInfo.function">function</a></code></li>
<li><code><a title="tsteno.language.parser.OpInfo.prec" href="#tsteno.language.parser.OpInfo.prec">prec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsteno.language.parser.ParensParser" href="#tsteno.language.parser.ParensParser">ParensParser</a></code></h4>
<ul class="">
<li><code><a title="tsteno.language.parser.ParensParser.read" href="#tsteno.language.parser.ParensParser.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsteno.language.parser.Parser" href="#tsteno.language.parser.Parser">Parser</a></code></h4>
<ul class="two-column">
<li><code><a title="tsteno.language.parser.Parser.binary_ops" href="#tsteno.language.parser.Parser.binary_ops">binary_ops</a></code></li>
<li><code><a title="tsteno.language.parser.Parser.compute_atom" href="#tsteno.language.parser.Parser.compute_atom">compute_atom</a></code></li>
<li><code><a title="tsteno.language.parser.Parser.compute_binop" href="#tsteno.language.parser.Parser.compute_binop">compute_binop</a></code></li>
<li><code><a title="tsteno.language.parser.Parser.compute_expr" href="#tsteno.language.parser.Parser.compute_expr">compute_expr</a></code></li>
<li><code><a title="tsteno.language.parser.Parser.compute_unary" href="#tsteno.language.parser.Parser.compute_unary">compute_unary</a></code></li>
<li><code><a title="tsteno.language.parser.Parser.get_nodes" href="#tsteno.language.parser.Parser.get_nodes">get_nodes</a></code></li>
<li><code><a title="tsteno.language.parser.Parser.parser_processors" href="#tsteno.language.parser.Parser.parser_processors">parser_processors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsteno.language.parser.UnaryOpParser" href="#tsteno.language.parser.UnaryOpParser">UnaryOpParser</a></code></h4>
<ul class="">
<li><code><a title="tsteno.language.parser.UnaryOpParser.read" href="#tsteno.language.parser.UnaryOpParser.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>